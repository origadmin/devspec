#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# This hook is designed to be used as a server-side pre-receive hook
# or update hook to enforce commit message standards.

# Read the commit message from stdin (for pre-receive) or from the file (for commit-msg hook)
# For pre-receive hook, the commit message is usually passed via stdin or by reading the commit object directly.
# For update hook, we iterate through new commits.

# Regex for Conventional Commits format
REGEX="^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?:\s.+$"

# Function to check a single commit message
check_commit_message() {
    MESSAGE=$1
    SUBJECT=$(echo "$MESSAGE" | head -n 1)

    # Allow Merge commits and Revert commits to pass without strict format check
    if echo "$SUBJECT" | grep -qE "^Merge" || echo "$SUBJECT" | grep -qE "^Revert"; then
        return 0
    fi

    # Check if subject matches the Conventional Commits format
    if ! echo "$SUBJECT" | grep -qE "$REGEX"; then
        echo "ERROR: Commit message \"$SUBJECT\" does not follow the Conventional Commits format." >&2
        echo "       Example: feat(scope): description" >&2
        return 1
    fi

    # Check subject length (optional, can be a warning)
    SUBJECT_LENGTH=$(echo "$SUBJECT" | wc -c | awk '{print $1}')
    if [ "$SUBJECT_LENGTH" -gt 72 ]; then
        echo "WARNING: Commit message \"$SUBJECT\" subject line is longer than 72 characters." >&2
    fi

    return 0
}

# Main logic for update hook (iterates through new commits)
# This part is typically used in an 'update' hook on the server.
# For 'pre-receive' hook, you'd read from stdin.

OLDREV=$1
NEWREV=$2
REFNAME=$3

# If it's a new branch or a fast-forward merge, check new commits
if [ "$OLDREV" = "0000000000000000000000000000000000000000" ]; then
    # New branch, check all commits on it
    COMMITS=$(git rev-list "$NEWREV")
else
    # Existing branch, check only new commits
    COMMITS=$(git rev-list "$OLDREV".."$NEWREV")
fi

for COMMIT in $COMMITS; do
    # Get the full commit message
    MESSAGE=$(git cat-file commit "$COMMIT" | sed '1,/^$/d')
    echo "Checking commit: $COMMIT"
    if ! check_commit_message "$MESSAGE"; then
        echo "" >&2
        echo "Push rejected: Commit message format violation." >&2
        echo "Please fix your commit messages and try again." >&2
        exit 1
    fi
done

exit 0
